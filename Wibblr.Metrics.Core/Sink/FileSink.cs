using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Wibblr.Collections;
using Wibblr.Metrics.Plugins.Interfaces;

namespace Wibblr.Metrics.Core
{
    /// <summary>
    /// Sink used for writing metrics to files. The serialization format (e.g. json, csv)
    /// is handled by an external serializer, and the file name is generated by an external class.
    /// </summary>
    public class FileSink : IMetricsSink
    {
        private IFileNamingStrategy _fileNamingStrategy;
        private IMetricsStreamSerializer _serializer;

        public FileSink(IMetricsStreamSerializer serializer, IFileNamingStrategy fileNamingStrategy)
        {
            _serializer = serializer;
            _fileNamingStrategy = fileNamingStrategy;
        }

        public void Flush(IEnumerable<WindowedCounter> counters)
        {
            if (counters.Any())
            {
                foreach (var partition in counters.Partition((a, b) => !_fileNamingStrategy.EqualNames(a, b)))
                {
                    var fileName = _fileNamingStrategy.BaseName(partition.First()) + "." + _serializer.FileExtension;
                    using (var stream = CreateOrOpen(fileName, x => _serializer.WriteCounterHeader(x)))
                        _serializer.Write(partition, stream);
                }
            }
        }

        public void Flush(IEnumerable<WindowedBucket> buckets)
        {
            if (buckets.Any())
            {
                foreach (var partition in buckets.Partition((a, b) => !_fileNamingStrategy.EqualNames(a, b)))
                {
                    var fileName = _fileNamingStrategy.BaseName(partition.First()) + "." + _serializer.FileExtension;
                    using (var stream = CreateOrOpen(fileName, x => _serializer.WriteBucketHeader(x)))
                        _serializer.Write(partition, stream);
                }
            }
        }

        public void Flush(IEnumerable<TimestampedEvent> events)
        {
            if (events.Any())
            {
                foreach (var partition in events.Partition((a, b) => !_fileNamingStrategy.EqualNames(a, b)))
                {
                    var fileName = _fileNamingStrategy.BaseName(partition.First()) + "." + _serializer.FileExtension;
                    using (var stream = CreateOrOpen(fileName, x => _serializer.WriteEventHeader(x)))
                        _serializer.Write(partition, stream);
                }
            }
        }

        public void Flush(IEnumerable<Profile> profiles)
        {
            if (profiles.Any())
            {
                foreach (var partition in profiles.Partition((a, b) => !_fileNamingStrategy.EqualNames(a, b)))
                {
                    var fileName = _fileNamingStrategy.BaseName(partition.First()) + "." + _serializer.FileExtension;
                    using (var stream = CreateOrOpen(fileName, x => _serializer.WriteProfileHeader(x)))
                    {
                        _serializer.Write(partition, stream);
                    }
                }
            }
        }

        public void FlushComplete()
        {
            // no op
        }

        /// <summary>
        /// Open a file, or create it if it does not exist.
        /// If creating the file, execute the OnCreate action; if opening the file
        /// then seek to the end so that writes will append.
        /// </summary>
        /// <param name="fileName">Name of file</param>
        /// <param name="OnCreate">Action to execute if file was created</param>
        /// <returns></returns>
        private Stream CreateOrOpen(string fileName, Action<Stream> OnCreate)
        {
            var stream = new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.ReadWrite);

            var len = stream.Length;

            if (len == 0)
                OnCreate(stream);
            else
                stream.Seek(len, SeekOrigin.Begin);
            
            return stream;
        }
    }
}

@page "/counter"
@inject RestApiClient restApiClient

@using System.Timers;
@using Wibblr.Metrics.RestApiModels

<h1>Counter</h1>

<MatButton @onclick="@(async e => await RefreshData())">Refresh Now</MatButton>

<MatSlideToggle TValue="bool" Label="Auto Refresh" ValueChanged="@(e => AutoRefreshChanged(e))" Style="padding-right:.5em"></MatSlideToggle>

<PlotlyChart @bind-Config="barConfig" @bind-Layout="barLayout" @bind-Data="barData" @ref="barChart" />

@code {
    Timer timer = new Timer(5000);

    PlotlyChart barChart;
    Config barConfig = new Config();

    Layout barLayout = new Layout
    {
      BarMode = Plotly.Blazor.LayoutLib.BarModeEnum.Group,
      Height = 500
    };

    IList<ITrace> barData = new List<ITrace>();

    private void AutoRefreshChanged(bool autoRefresh)
    {
      timer.Enabled = autoRefresh;
      timer.AutoReset = true;
    }

    protected override void OnInitialized()
    {
      timer.Elapsed += OnTimer;
    }


    private void OnTimer(object source, ElapsedEventArgs e)
    {
      InvokeAsync(async () => await RefreshData());
    }

    // There must be a better way to prevent multiple simultaneous timer events
    bool isRefreshing = false;

    private async Task RefreshData()
    {
      if (isRefreshing)
      {
        Console.WriteLine("IsRefreshing");
        return;
      }
      try
      {
        isRefreshing = true;

        var now = DateTimeOffset.Now;
        var counterResponse = await restApiClient.GetCountersAsync(new[] { "%" }, now.Subtract(TimeSpan.FromHours(1)), now, TimeSpan.FromSeconds(300));

        await barChart.Clear();

        foreach (var c in counterResponse)
        {
          await barChart.AddTrace(
              new Bar
              {
                Name = c.Name,
                X = Enumerable.Range(1, c.Values.Count).Select(x => (object)c.From.AddSeconds(x * c.GroupBySeconds)).ToList(),
                Y = c.Values
              });
        }
      }
      finally
      {
        isRefreshing = false;
      }
    }
}
